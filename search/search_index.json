{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"contact/","title":"Contact","text":"<p>Jakob H\u00e6rvig, Associate Professor, AAU Energy, Aalborg University</p> <p>jah@energy.aau.dk</p>"},{"location":"contributing/","title":"Contributing","text":"<p>OpenTerrace is all open-source and contributions are most welcome.</p>"},{"location":"contributing/#code-development","title":"Code development","text":"<ul> <li>Smaller contributions fitting nicely into the existing modelling framework (e.g. a new fluid or bed material). These can be included by a simple pull request to the development branch.</li> <li>Larger contributions requiring revision of existing classes or core functionality. Please reach out beforehand to discuss.</li> <li>If you intend to use OpenTerrace in product development or research and require any assistance you are also most welcome to get in touch.</li> </ul>"},{"location":"contributing/#collaborations","title":"Collaborations","text":"<p>OpenTerrace welcomes collaborations within packed bed thermal storage systems. Please get in touch to discuss further.</p>"},{"location":"installation/","title":"Installation guide","text":"<p>First make sure you have a working installation of Python. If you have never worked with Python before, we recommend installing Miniconda alongside the Visual Studio Code text editor. After selecting Miniconda as the Python interpreter in VS Code, you may now install OpenTerrace using pip:</p>"},{"location":"installation/#install-using-pip","title":"Install using <code>pip</code>","text":"<pre><code>pip install openterrace\n</code></pre>"},{"location":"installation/#install-in-editable-mode","title":"Install in editable mode","text":"<ol> <li> <p>If you plan on extending or modifying OpenTerrace, you should install it in editable mode. First, use any git client such as GitHub Desktop to clone the OpenTerrace repository</p> </li> <li> <p>Next, I recommend using Linux or WSL (if on Windows). Inside a linux terminal do: <pre><code>mkdir -p ~/miniconda3\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh\nbash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3\nrm -rf ~/miniconda3/miniconda.sh\n</code></pre></p> </li> <li> <p>Then, initialise your conda environment: <pre><code>~/miniconda3/bin/conda init bash\n</code></pre></p> </li> <li> <p>Now, reopen your terminal and create a virtual environment called <code>ot</code>: <pre><code>conda create -n ot\n</code></pre></p> </li> <li> <p>Then activate it: <pre><code>conda activate ot\n</code></pre></p> </li> <li> <p>Make sure to use compatible Python version: <pre><code>conda install python=3.11\n</code></pre></p> </li> <li> <p>Install pip inside the <code>ot</code> environment <pre><code>conda install pip\n</code></pre></p> </li> <li> <p>Verify that the right pip version is picked up: <pre><code>which pip\n</code></pre> which should give you something like <code>/home/[username]/miniconda3/envs/ot/bin/pip</code></p> </li> <li> <p>Finally, install OpenTerrace inside our virtual environment by navigating to the \"openterrace-python\" folder and install in editable mode by: <pre><code>pip install --editable .\n</code></pre></p> </li> <li> <p>Verify that the <code>ot</code> virtual environment is picked up as the interpreter in VS Code.</p> </li> </ol> <p></p> <p>Now you are ready to run tutorials and modify the OpenTerrace like as you like.</p>"},{"location":"source_code/","title":"Source code","text":""},{"location":"source_code/#openterrace.openterrace.Simulate","title":"<code>Simulate</code>","text":"<p>OpenTerrace class.</p> Source code in <code>openterrace/openterrace.py</code> <pre><code>class Simulate:\n    \"\"\"OpenTerrace class.\"\"\"\n    def __init__(self, t_end:float=None, dt:float=None, sim_name:str=None):\n        \"\"\"Initialise with various control parameters.\n\n        Args:\n            t_end (float): End time in s\n            dt (float): Time step size in s\n            sim_name (str): Simulation name\n        \"\"\"\n        self.t_start = 0\n        self.t_end = t_end\n        self.dt = dt\n        self.coupling = []\n        self.flag_coupling = False\n        self.sim_name = sim_name\n\n    def createPhase(self, n:int=None, n_other:int=1, type:str=None):\n        \"\"\"Creates a fluid or bed phase.\n\n        Args:\n            n (int): Number of discretisations\n            n_other (int): Number of discretisations of interacting phase. If you are defining a bed phase within a tank. Then n_other is the number of discretisations of the fluid phase.\n            type (str): Simulation name\n        \"\"\"\n        return self.Phase(self, n, n_other, type)\n\n    def select_coupling(self, fluid_phase:int=None, bed_phase:int=None, h_exp:str=None, h_value:float=None):\n        \"\"\"Selects coupling of a fluid and bed phase\n\n        Args:\n            fluid_phase (int): phase number\n            bed_phase (int): phase number\n            h_exp (str): Predefined function for convective heat transfer\n            h_value (float): Convective heat transfer coefficient in W/(m^2 K)\n        \"\"\"\n        valid_h_exp = ['constant']\n        if h_exp not in valid_h_exp:\n            raise Exception(\"h_exp \\'\"+h_exp+\"\\' specified. Valid options for h_exp are:\", valid_h_exp)\n\n        self.coupling.append({\"fluid_phase\":fluid_phase, \"bed_phase\":bed_phase, \"h_exp\":h_exp, \"h_value\":h_value})\n        self.flag_coupling = True\n\n    def _coupling(self):\n        for couple in self.coupling:\n            Q = couple['h_value']*self.Phase.instances[couple['bed_phase']].domain.A[-1][-1]*(self.Phase.instances[couple['fluid_phase']].T[0]-self.Phase.instances[couple['bed_phase']].T[:,-1])*self.dt\n            self.Phase.instances[couple['bed_phase']].h[:,-1] = self.Phase.instances[couple['bed_phase']].h[:,-1] + Q/(self.Phase.instances[couple['bed_phase']].rho[:,-1] * self.Phase.instances[couple['bed_phase']].domain.V[-1])\n            self.Phase.instances[couple['fluid_phase']].h[0] = self.Phase.instances[couple['fluid_phase']].h[0] - (1-self.Phase.instances[couple['fluid_phase']].phi)*(self.Phase.instances[couple['fluid_phase']].domain.V * self.Phase.instances[couple['fluid_phase']].phi) / np.sum(self.Phase.instances[couple['bed_phase']].domain.V) * Q/(self.Phase.instances[couple['fluid_phase']].rho*self.Phase.instances[couple['fluid_phase']].domain.V)\n\n    def run_simulation(self):\n        \"\"\"This is the function full of magic.\"\"\"\n        for t in tqdm.tqdm(np.arange(self.t_start, self.t_end+self.dt, self.dt)):\n            for phase_instance in self.Phase.instances:\n                phase_instance._save_data(t)\n                phase_instance._solve_equations(t, self.dt)\n                phase_instance._update_properties()\n            if self.flag_coupling:\n                self._coupling()\n\n    def generate_plot(self, pos_phase:object=None, data_phase:object=None, parameter:str='T'):\n        filename='ot_plot_'+self.sim_name+'_'+pos_phase.type+'_'+data_phase.type+'_'+parameter+'.png'\n        x = pos_phase.domain.node_pos\n\n        if pos_phase == data_phase:\n            y = np.mean(getattr(data_phase.data, parameter),1)\n        else:\n            y = np.mean(getattr(data_phase.data, parameter),2)\n        times = getattr(data_phase.data, 'time')\n\n        if y.shape[1] == 1:\n            y = np.append(y, y, 1)\n\n        fig, axes = plt.subplots()\n        for i,time in enumerate(times):\n            timelabel = u'$%s$' % time\n            plt.plot(x, y[i,:].transpose()-273.15, label=timelabel)\n\n        lines = plt.gca().get_lines()\n        labelLines(lines, fontsize=8, align=True)\n\n        plt.grid()\n        plt.xlabel('Position (m)')\n        plt.ylabel(u'$%s_{%s}$ (\\u00B0C)' % (parameter, data_phase.type))\n        plt.savefig(filename)\n\n    def generate_animation(self, pos_phase:object=None, data_phase:object=None, parameter:str='T'):\n        def _update(frame, parameter):\n            x = pos_phase.domain.node_pos\n            if pos_phase == data_phase:\n                y = np.mean(getattr(data_phase.data, parameter),1)\n            else:\n                y = np.mean(getattr(data_phase.data, parameter),2)\n            times = getattr(data_phase.data, 'time')\n\n            if y.shape[1] == 1:\n                y = np.append(y, y, 1)\n\n            ax.clear()\n            ax.set_xlabel('Position (m)')\n            ax.set_ylabel(u'$%s_{%s}$ (\\u00B0C)' % (parameter, data_phase.type))\n            ax.set_xlim(np.min(pos_phase.domain.node_pos), np.max(pos_phase.domain.node_pos))\n            ax.set_ylim(np.min(getattr(data_phase.data,parameter)-273.15)-0.05*(np.max(getattr(data_phase.data, parameter)-273.15)), np.max(getattr(data_phase.data, parameter)-273.15)+0.05*(np.max(getattr(data_phase.data, parameter)-273.15)))\n            ax.grid()\n            ax.plot(x, y[frame,:].transpose()-273.15, color = '#4cae4f')\n            ax.set_title('Time: ' + str(np.round(getattr(data_phase.data, 'time')[frame], decimals=2)) + ' s')\n\n        parameter = 'T'\n        fig, ax = plt.subplots()\n        fig.tight_layout(pad=2)\n        filename='ot_ani_'+self.sim_name+'_'+pos_phase.type+'_'+data_phase.type+'_'+parameter+'.gif'\n        ani = anim.FuncAnimation(fig, _update, fargs=parameter, frames=np.arange(len(getattr(data_phase.data, parameter))))\n        ani.save(filename, writer=anim.PillowWriter(fps=5), progress_callback=lambda i, n: print(f'{data_phase.type}: saving animation frame {i}/{n}'))\n\n    class Phase:\n        instances = []\n        \"\"\"Main class to define either the fluid or bed phase.\"\"\"\n        def __init__(self, outer=None, n:int=None, n_other:int=None, type:str=None):\n            \"\"\"Initialise a phase with number of control points and type.\n\n            Args:\n                n_self (int): Number of discretisations for the given phase\n                n_other (int): Number of discretisations for the other phase\n                type (str): Type of phase\n            \"\"\"\n            self.outer = outer\n            self.__class__.instances.append(self)\n            self.n = n\n            self.n_other = n_other\n\n            self.phi = 1\n            self.bcs = []\n            self.sources = []\n\n            self._flag_save_data = False\n\n            self.type = type\n            self._valid_inputs(type)\n\n        def _valid_inputs(self, type:str=None):\n            \"\"\"Gets valid domain and substances depending on type of phase.\n            \"\"\"\n            self.valid_domains = globals()['domains'].__all__\n            self.valid_substances = globals()[type+'_substances'].__all__\n\n        def select_substance_on_the_fly(self, cp:float=None, rho:float=None, k:float=None):\n            \"\"\"Defines and selects a new substance on-the-fly. This is useful for defining a substance for testing purposes with temperature independent properties.\n\n            Args:\n                cp (float): Specific heat capacity in J/(kg K)\n                rho (float): Density in kg/m^3\n                k (float): Thermal conductivity in W/(m K)\n            \"\"\"\n            class dummy:\n                pass\n            self.fcns = dummy()\n            self.fcns.h = lambda T: np.ones_like(T)*T*cp\n            self.fcns.T = lambda h: np.ones_like(h)*h/cp\n            self.fcns.cp = lambda h: np.ones_like(h)*cp\n            self.fcns.k = lambda h: np.ones_like(h)*k\n            self.fcns.rho = lambda h: np.ones_like(h)*rho\n\n        def select_substance(self, substance:str=None):\n            \"\"\"Selects one of the predefined substancers.\n\n            Args:\n                substance (str): Substance name\n            \"\"\"\n            if not substance:\n                raise Exception(\"Keyword 'substance' not specified.\")\n            if not substance in self.valid_substances:\n                raise Exception(substance+\" specified as \"+self.type+\" substance. Valid \"+self.type+\" substances are:\", self.valid_substances)\n            self.fcns = getattr(globals()[self.type+'_substances'], substance)\n\n        def select_domain_shape(self, domain:str=None, **kwargs):\n            \"\"\"Select domain shape and initialise constants.\"\"\"\n            kwargs['n'] = self.n\n            if not domain:\n                raise Exception(\"Keyword 'domain' not specified.\")\n            if not domain in globals()['domains'].__all__:\n                raise Exception(\"domain \\'\"+domain+\"\\' specified. Valid options for domain are:\", self.valid_domains)\n            self.domain = getattr(globals()['domains'], domain)\n            self.domain.type = domain\n            self.domain.validate_input(kwargs, domain)\n            self.domain.shape = self.domain.shape(kwargs)\n            self.domain.node_pos = self.domain.node_pos(kwargs)\n            self.domain.dx = self.domain.dx(kwargs)\n            self.domain.A = self.domain.A(kwargs)\n            self.domain.V = self.domain.V(kwargs)\n\n        def select_porosity(self, phi:float=1):\n            \"\"\"Select porosity from 0 to 1, e.g. filling the domain with the phase up to a certain degree.\"\"\"\n            self.domain.V = self.domain.V*phi\n            self.phi = phi\n\n        def select_schemes(self, diff:str=None, conv:str=None):\n            \"\"\"Imports the specified diffusion and convection schemes.\"\"\"\n\n            if self.domain.type == 'lumped':\n                raise Exception(\"'lumped' has been selected as domain type. Please don't specify a discretisation scheme.\")\n\n            if diff is not None:\n                try:\n                    self.diff = getattr(getattr(globals()['diffusion_schemes'], diff), diff)\n                except:\n                    raise Exception(\"Diffusion scheme \\'\"+diff+\"\\' specified. Valid options for diffusion schemes are:\", diffusion_schemes.__all__)\n\n            if conv is not None:\n                try:\n                    self.conv = getattr(getattr(globals()['convection_schemes'], conv), conv)\n                except:\n                    raise Exception(\"Convection scheme \\'\"+conv+\"\\' specified. Valid options for convection schemes are:\", convection_schemes.__all__)\n\n        def select_initial_conditions(self, T:float=None):\n            \"\"\"Initialises temperature and massflow fields\"\"\"\n            if T is not None:\n                self.T = np.tile(T,(np.append(self.n_other,self.domain.shape)))\n                self.h = self.fcns.h(self.T)\n            self.T = self.fcns.T(self.h)\n            self.rho = self.fcns.rho(self.h)\n            self.cp = self.fcns.cp(self.h)\n            self.k = self.fcns.k(self.h)\n            self.D = np.zeros(((2,)+(self.T.shape)))\n            self.F = np.zeros(((2,)+(self.T.shape)))\n            self.S = np.zeros(self.T.shape)\n\n        def select_massflow(self, mdot:list[float]=None):\n            self.mdot_array = np.array(mdot)\n\n        def select_bc(self, bc_type:str=None, parameter:str=None, position=None, value:float=None):\n            \"\"\"Specify boundary condition type\"\"\"\n            valid_bc_types = ['fixedValue','zeroGradient']\n            if bc_type not in valid_bc_types:\n                raise Exception(\"bc_type \\'\"+bc_type+\"\\' specified. Valid options for bc_type are:\", valid_bc_types)\n            valid_parameters = ['T','mdot']\n            if parameter not in valid_parameters:\n                raise Exception(\"parameter \\'\"+parameter+\"\\' specified. Valid options for parameter are:\", valid_parameters)\n            if not position:\n                raise Exception(\"Keyword 'position' not specified.\")\n            if value is None and bc_type=='fixedValue':\n                raise Exception(\"Keyword 'value' is needed for fixedValue type bc.\")\n            self.bcs.append({'type': bc_type, 'parameter': parameter, 'position': position, 'value': np.array(value)})\n\n        def select_source_term(self, **kwargs):\n            valid_source_types = ['thermal_resistance']\n            if kwargs['source_type'] not in valid_source_types:\n                raise Exception(\"source_type \\'\"+kwargs['source_type']+\"\\' specified. Valid options for source_type are:\", valid_source_types)\n            if kwargs['source_type'] == 'thermal_resistance':\n                required = ['R','T_inf', 'position']\n                for var in required:\n                    if not var in kwargs:\n                        raise Exception(\"Keyword \\'\"+var+\"\\' not specified for source of type \\'\"+kwargs['source_type']+\"\\'\")\n            self.sources.append(kwargs)\n\n        def select_output(self, times:list[float]=None, parameters:list[str]=None):\n            class Data(object):\n                pass\n            self.data = Data()\n            self.data.time = np.intersect1d(np.array(times), np.arange(self.outer.t_start, self.outer.t_end+self.outer.dt, self.outer.dt))\n            self.data.parameters = parameters\n            for parameter in parameters:\n                setattr(self.data,parameter, np.full((len(self.data.time), self.n_other, self.n),np.nan))\n                self._flag_save_data = True\n                self._q = 0\n\n        def _save_data(self, t:float=None):\n            if self._flag_save_data:\n                if t in self.data.time:\n                    self.data.time[self._q] = t\n                    for parameter in self.data.parameters: \n                        getattr(self.data,parameter)[self._q] = getattr(self,parameter)\n                        self._q = self._q+1\n\n        def _update_massflow_rate(self, t:float=None):\n            \"\"\"Updates mass flow rate\"\"\"\n            if self.mdot_array.ndim == 0:\n                self.mdot = np.tile(self.mdot_array,(np.append(self.n_other,self.domain.shape)))\n            elif self.mdot_array.ndim == 2:\n                self.mdot = np.interp(t, self.mdot_array[:,0], self.mdot_array[:,1])\n\n        def _update_properties(self):\n            \"\"\"Updates properties based on specific enthalpy\"\"\"\n            self.T = self.fcns.T(self.h)\n            self.rho = self.fcns.rho(self.h)\n            self.cp = self.fcns.cp(self.h)\n\n            if hasattr(self, 'diff'):\n                self.k = self.fcns.k(self.h)\n                self.D[0,:,:] = self.k*self.domain.A[0]/self.domain.dx\n                self.D[1,:,:] = self.k*self.domain.A[1]/self.domain.dx\n\n            if hasattr(self, 'conv'):\n                self.F[0,:,:] = self.mdot*self.cp\n                self.F[1,:,:] = self.mdot*self.cp\n\n        def _update_boundary_nodes(self, t:float=None, dt:float=None):\n            \"\"\"Update boundary nodes\"\"\"\n            for bc in self.bcs:\n                if bc['type'] == 'fixedValue':\n                    self.h[bc['position']] = self.fcns.h(bc['value'])\n                if bc['type'] == 'fixedValue_timevarying':\n                    self.h[bc['position']] = self.fcns.h(np.interp(t,bc['value'][:,0],bc['value'][:,1]))\n                if bc['type'] == 'zeroGradient':\n                    if bc['position'] == np.s_[:,0]:\n                        self.h[bc['position']] = self.h[bc['position']] + (2*self.T[:,1]*self.D[1,:,0] - 2*self.T[:,0]*self.D[1,:,0] - self.F[0,:,1]*self.T[:,1] + self.F[1,:,0]*self.T[:,0]) / (self.rho[:,0]*self.domain.V[0])*dt\n                    if bc['position'] == np.s_[:,-1]:\n                        self.h[bc['position']] = self.h[bc['position']] + (2*self.T[:,-2]*self.D[0,:,-1] - 2*self.T[:,-1]*self.D[0,:,-1] + self.F[1,:,-2]*self.T[:,-2] - self.F[0,:,-1]*self.T[:,-1]) / (self.rho[:,-1]*self.domain.V[-1])*dt\n\n        def _update_source(self, dt:float=None):\n            for source in self.sources:\n                if source['source_type'] == 'thermal_resistance':\n                    self.h[source['position']] = self.h[source['position']] + (2/source['R'] * (source['T_inf']-self.T[source['position']])) / (self.rho[source['position']]*self.domain.V[source['position'][1]])*dt\n\n        def _solve_equations(self, t:float=None, dt:float=None):\n            self._update_boundary_nodes(t, dt)\n            if hasattr(self, 'diff'):\n                self.h = self.h + self.diff(self.T, self.D)/(self.rho*self.domain.V)*dt\n            if hasattr(self, 'conv'):\n                self._update_massflow_rate()\n                self.h = self.h + self.conv(self.T, self.F)/(self.rho*self.domain.V)*dt\n            if self.sources is not None:\n                self._update_source(dt)\n</code></pre>"},{"location":"source_code/#openterrace.openterrace.Simulate.Phase","title":"<code>Phase</code>","text":"Source code in <code>openterrace/openterrace.py</code> <pre><code>class Phase:\n    instances = []\n    \"\"\"Main class to define either the fluid or bed phase.\"\"\"\n    def __init__(self, outer=None, n:int=None, n_other:int=None, type:str=None):\n        \"\"\"Initialise a phase with number of control points and type.\n\n        Args:\n            n_self (int): Number of discretisations for the given phase\n            n_other (int): Number of discretisations for the other phase\n            type (str): Type of phase\n        \"\"\"\n        self.outer = outer\n        self.__class__.instances.append(self)\n        self.n = n\n        self.n_other = n_other\n\n        self.phi = 1\n        self.bcs = []\n        self.sources = []\n\n        self._flag_save_data = False\n\n        self.type = type\n        self._valid_inputs(type)\n\n    def _valid_inputs(self, type:str=None):\n        \"\"\"Gets valid domain and substances depending on type of phase.\n        \"\"\"\n        self.valid_domains = globals()['domains'].__all__\n        self.valid_substances = globals()[type+'_substances'].__all__\n\n    def select_substance_on_the_fly(self, cp:float=None, rho:float=None, k:float=None):\n        \"\"\"Defines and selects a new substance on-the-fly. This is useful for defining a substance for testing purposes with temperature independent properties.\n\n        Args:\n            cp (float): Specific heat capacity in J/(kg K)\n            rho (float): Density in kg/m^3\n            k (float): Thermal conductivity in W/(m K)\n        \"\"\"\n        class dummy:\n            pass\n        self.fcns = dummy()\n        self.fcns.h = lambda T: np.ones_like(T)*T*cp\n        self.fcns.T = lambda h: np.ones_like(h)*h/cp\n        self.fcns.cp = lambda h: np.ones_like(h)*cp\n        self.fcns.k = lambda h: np.ones_like(h)*k\n        self.fcns.rho = lambda h: np.ones_like(h)*rho\n\n    def select_substance(self, substance:str=None):\n        \"\"\"Selects one of the predefined substancers.\n\n        Args:\n            substance (str): Substance name\n        \"\"\"\n        if not substance:\n            raise Exception(\"Keyword 'substance' not specified.\")\n        if not substance in self.valid_substances:\n            raise Exception(substance+\" specified as \"+self.type+\" substance. Valid \"+self.type+\" substances are:\", self.valid_substances)\n        self.fcns = getattr(globals()[self.type+'_substances'], substance)\n\n    def select_domain_shape(self, domain:str=None, **kwargs):\n        \"\"\"Select domain shape and initialise constants.\"\"\"\n        kwargs['n'] = self.n\n        if not domain:\n            raise Exception(\"Keyword 'domain' not specified.\")\n        if not domain in globals()['domains'].__all__:\n            raise Exception(\"domain \\'\"+domain+\"\\' specified. Valid options for domain are:\", self.valid_domains)\n        self.domain = getattr(globals()['domains'], domain)\n        self.domain.type = domain\n        self.domain.validate_input(kwargs, domain)\n        self.domain.shape = self.domain.shape(kwargs)\n        self.domain.node_pos = self.domain.node_pos(kwargs)\n        self.domain.dx = self.domain.dx(kwargs)\n        self.domain.A = self.domain.A(kwargs)\n        self.domain.V = self.domain.V(kwargs)\n\n    def select_porosity(self, phi:float=1):\n        \"\"\"Select porosity from 0 to 1, e.g. filling the domain with the phase up to a certain degree.\"\"\"\n        self.domain.V = self.domain.V*phi\n        self.phi = phi\n\n    def select_schemes(self, diff:str=None, conv:str=None):\n        \"\"\"Imports the specified diffusion and convection schemes.\"\"\"\n\n        if self.domain.type == 'lumped':\n            raise Exception(\"'lumped' has been selected as domain type. Please don't specify a discretisation scheme.\")\n\n        if diff is not None:\n            try:\n                self.diff = getattr(getattr(globals()['diffusion_schemes'], diff), diff)\n            except:\n                raise Exception(\"Diffusion scheme \\'\"+diff+\"\\' specified. Valid options for diffusion schemes are:\", diffusion_schemes.__all__)\n\n        if conv is not None:\n            try:\n                self.conv = getattr(getattr(globals()['convection_schemes'], conv), conv)\n            except:\n                raise Exception(\"Convection scheme \\'\"+conv+\"\\' specified. Valid options for convection schemes are:\", convection_schemes.__all__)\n\n    def select_initial_conditions(self, T:float=None):\n        \"\"\"Initialises temperature and massflow fields\"\"\"\n        if T is not None:\n            self.T = np.tile(T,(np.append(self.n_other,self.domain.shape)))\n            self.h = self.fcns.h(self.T)\n        self.T = self.fcns.T(self.h)\n        self.rho = self.fcns.rho(self.h)\n        self.cp = self.fcns.cp(self.h)\n        self.k = self.fcns.k(self.h)\n        self.D = np.zeros(((2,)+(self.T.shape)))\n        self.F = np.zeros(((2,)+(self.T.shape)))\n        self.S = np.zeros(self.T.shape)\n\n    def select_massflow(self, mdot:list[float]=None):\n        self.mdot_array = np.array(mdot)\n\n    def select_bc(self, bc_type:str=None, parameter:str=None, position=None, value:float=None):\n        \"\"\"Specify boundary condition type\"\"\"\n        valid_bc_types = ['fixedValue','zeroGradient']\n        if bc_type not in valid_bc_types:\n            raise Exception(\"bc_type \\'\"+bc_type+\"\\' specified. Valid options for bc_type are:\", valid_bc_types)\n        valid_parameters = ['T','mdot']\n        if parameter not in valid_parameters:\n            raise Exception(\"parameter \\'\"+parameter+\"\\' specified. Valid options for parameter are:\", valid_parameters)\n        if not position:\n            raise Exception(\"Keyword 'position' not specified.\")\n        if value is None and bc_type=='fixedValue':\n            raise Exception(\"Keyword 'value' is needed for fixedValue type bc.\")\n        self.bcs.append({'type': bc_type, 'parameter': parameter, 'position': position, 'value': np.array(value)})\n\n    def select_source_term(self, **kwargs):\n        valid_source_types = ['thermal_resistance']\n        if kwargs['source_type'] not in valid_source_types:\n            raise Exception(\"source_type \\'\"+kwargs['source_type']+\"\\' specified. Valid options for source_type are:\", valid_source_types)\n        if kwargs['source_type'] == 'thermal_resistance':\n            required = ['R','T_inf', 'position']\n            for var in required:\n                if not var in kwargs:\n                    raise Exception(\"Keyword \\'\"+var+\"\\' not specified for source of type \\'\"+kwargs['source_type']+\"\\'\")\n        self.sources.append(kwargs)\n\n    def select_output(self, times:list[float]=None, parameters:list[str]=None):\n        class Data(object):\n            pass\n        self.data = Data()\n        self.data.time = np.intersect1d(np.array(times), np.arange(self.outer.t_start, self.outer.t_end+self.outer.dt, self.outer.dt))\n        self.data.parameters = parameters\n        for parameter in parameters:\n            setattr(self.data,parameter, np.full((len(self.data.time), self.n_other, self.n),np.nan))\n            self._flag_save_data = True\n            self._q = 0\n\n    def _save_data(self, t:float=None):\n        if self._flag_save_data:\n            if t in self.data.time:\n                self.data.time[self._q] = t\n                for parameter in self.data.parameters: \n                    getattr(self.data,parameter)[self._q] = getattr(self,parameter)\n                    self._q = self._q+1\n\n    def _update_massflow_rate(self, t:float=None):\n        \"\"\"Updates mass flow rate\"\"\"\n        if self.mdot_array.ndim == 0:\n            self.mdot = np.tile(self.mdot_array,(np.append(self.n_other,self.domain.shape)))\n        elif self.mdot_array.ndim == 2:\n            self.mdot = np.interp(t, self.mdot_array[:,0], self.mdot_array[:,1])\n\n    def _update_properties(self):\n        \"\"\"Updates properties based on specific enthalpy\"\"\"\n        self.T = self.fcns.T(self.h)\n        self.rho = self.fcns.rho(self.h)\n        self.cp = self.fcns.cp(self.h)\n\n        if hasattr(self, 'diff'):\n            self.k = self.fcns.k(self.h)\n            self.D[0,:,:] = self.k*self.domain.A[0]/self.domain.dx\n            self.D[1,:,:] = self.k*self.domain.A[1]/self.domain.dx\n\n        if hasattr(self, 'conv'):\n            self.F[0,:,:] = self.mdot*self.cp\n            self.F[1,:,:] = self.mdot*self.cp\n\n    def _update_boundary_nodes(self, t:float=None, dt:float=None):\n        \"\"\"Update boundary nodes\"\"\"\n        for bc in self.bcs:\n            if bc['type'] == 'fixedValue':\n                self.h[bc['position']] = self.fcns.h(bc['value'])\n            if bc['type'] == 'fixedValue_timevarying':\n                self.h[bc['position']] = self.fcns.h(np.interp(t,bc['value'][:,0],bc['value'][:,1]))\n            if bc['type'] == 'zeroGradient':\n                if bc['position'] == np.s_[:,0]:\n                    self.h[bc['position']] = self.h[bc['position']] + (2*self.T[:,1]*self.D[1,:,0] - 2*self.T[:,0]*self.D[1,:,0] - self.F[0,:,1]*self.T[:,1] + self.F[1,:,0]*self.T[:,0]) / (self.rho[:,0]*self.domain.V[0])*dt\n                if bc['position'] == np.s_[:,-1]:\n                    self.h[bc['position']] = self.h[bc['position']] + (2*self.T[:,-2]*self.D[0,:,-1] - 2*self.T[:,-1]*self.D[0,:,-1] + self.F[1,:,-2]*self.T[:,-2] - self.F[0,:,-1]*self.T[:,-1]) / (self.rho[:,-1]*self.domain.V[-1])*dt\n\n    def _update_source(self, dt:float=None):\n        for source in self.sources:\n            if source['source_type'] == 'thermal_resistance':\n                self.h[source['position']] = self.h[source['position']] + (2/source['R'] * (source['T_inf']-self.T[source['position']])) / (self.rho[source['position']]*self.domain.V[source['position'][1]])*dt\n\n    def _solve_equations(self, t:float=None, dt:float=None):\n        self._update_boundary_nodes(t, dt)\n        if hasattr(self, 'diff'):\n            self.h = self.h + self.diff(self.T, self.D)/(self.rho*self.domain.V)*dt\n        if hasattr(self, 'conv'):\n            self._update_massflow_rate()\n            self.h = self.h + self.conv(self.T, self.F)/(self.rho*self.domain.V)*dt\n        if self.sources is not None:\n            self._update_source(dt)\n</code></pre>"},{"location":"source_code/#openterrace.openterrace.Simulate.Phase.instances","title":"<code>instances = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Main class to define either the fluid or bed phase.</p>"},{"location":"source_code/#openterrace.openterrace.Simulate.Phase.__init__","title":"<code>__init__(outer=None, n=None, n_other=None, type=None)</code>","text":"<p>Initialise a phase with number of control points and type.</p> <p>Parameters:</p> Name Type Description Default <code>n_self</code> <code>int</code> <p>Number of discretisations for the given phase</p> required <code>n_other</code> <code>int</code> <p>Number of discretisations for the other phase</p> <code>None</code> <code>type</code> <code>str</code> <p>Type of phase</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def __init__(self, outer=None, n:int=None, n_other:int=None, type:str=None):\n    \"\"\"Initialise a phase with number of control points and type.\n\n    Args:\n        n_self (int): Number of discretisations for the given phase\n        n_other (int): Number of discretisations for the other phase\n        type (str): Type of phase\n    \"\"\"\n    self.outer = outer\n    self.__class__.instances.append(self)\n    self.n = n\n    self.n_other = n_other\n\n    self.phi = 1\n    self.bcs = []\n    self.sources = []\n\n    self._flag_save_data = False\n\n    self.type = type\n    self._valid_inputs(type)\n</code></pre>"},{"location":"source_code/#openterrace.openterrace.Simulate.Phase.select_bc","title":"<code>select_bc(bc_type=None, parameter=None, position=None, value=None)</code>","text":"<p>Specify boundary condition type</p> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_bc(self, bc_type:str=None, parameter:str=None, position=None, value:float=None):\n    \"\"\"Specify boundary condition type\"\"\"\n    valid_bc_types = ['fixedValue','zeroGradient']\n    if bc_type not in valid_bc_types:\n        raise Exception(\"bc_type \\'\"+bc_type+\"\\' specified. Valid options for bc_type are:\", valid_bc_types)\n    valid_parameters = ['T','mdot']\n    if parameter not in valid_parameters:\n        raise Exception(\"parameter \\'\"+parameter+\"\\' specified. Valid options for parameter are:\", valid_parameters)\n    if not position:\n        raise Exception(\"Keyword 'position' not specified.\")\n    if value is None and bc_type=='fixedValue':\n        raise Exception(\"Keyword 'value' is needed for fixedValue type bc.\")\n    self.bcs.append({'type': bc_type, 'parameter': parameter, 'position': position, 'value': np.array(value)})\n</code></pre>"},{"location":"source_code/#openterrace.openterrace.Simulate.Phase.select_domain_shape","title":"<code>select_domain_shape(domain=None, **kwargs)</code>","text":"<p>Select domain shape and initialise constants.</p> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_domain_shape(self, domain:str=None, **kwargs):\n    \"\"\"Select domain shape and initialise constants.\"\"\"\n    kwargs['n'] = self.n\n    if not domain:\n        raise Exception(\"Keyword 'domain' not specified.\")\n    if not domain in globals()['domains'].__all__:\n        raise Exception(\"domain \\'\"+domain+\"\\' specified. Valid options for domain are:\", self.valid_domains)\n    self.domain = getattr(globals()['domains'], domain)\n    self.domain.type = domain\n    self.domain.validate_input(kwargs, domain)\n    self.domain.shape = self.domain.shape(kwargs)\n    self.domain.node_pos = self.domain.node_pos(kwargs)\n    self.domain.dx = self.domain.dx(kwargs)\n    self.domain.A = self.domain.A(kwargs)\n    self.domain.V = self.domain.V(kwargs)\n</code></pre>"},{"location":"source_code/#openterrace.openterrace.Simulate.Phase.select_initial_conditions","title":"<code>select_initial_conditions(T=None)</code>","text":"<p>Initialises temperature and massflow fields</p> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_initial_conditions(self, T:float=None):\n    \"\"\"Initialises temperature and massflow fields\"\"\"\n    if T is not None:\n        self.T = np.tile(T,(np.append(self.n_other,self.domain.shape)))\n        self.h = self.fcns.h(self.T)\n    self.T = self.fcns.T(self.h)\n    self.rho = self.fcns.rho(self.h)\n    self.cp = self.fcns.cp(self.h)\n    self.k = self.fcns.k(self.h)\n    self.D = np.zeros(((2,)+(self.T.shape)))\n    self.F = np.zeros(((2,)+(self.T.shape)))\n    self.S = np.zeros(self.T.shape)\n</code></pre>"},{"location":"source_code/#openterrace.openterrace.Simulate.Phase.select_porosity","title":"<code>select_porosity(phi=1)</code>","text":"<p>Select porosity from 0 to 1, e.g. filling the domain with the phase up to a certain degree.</p> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_porosity(self, phi:float=1):\n    \"\"\"Select porosity from 0 to 1, e.g. filling the domain with the phase up to a certain degree.\"\"\"\n    self.domain.V = self.domain.V*phi\n    self.phi = phi\n</code></pre>"},{"location":"source_code/#openterrace.openterrace.Simulate.Phase.select_schemes","title":"<code>select_schemes(diff=None, conv=None)</code>","text":"<p>Imports the specified diffusion and convection schemes.</p> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_schemes(self, diff:str=None, conv:str=None):\n    \"\"\"Imports the specified diffusion and convection schemes.\"\"\"\n\n    if self.domain.type == 'lumped':\n        raise Exception(\"'lumped' has been selected as domain type. Please don't specify a discretisation scheme.\")\n\n    if diff is not None:\n        try:\n            self.diff = getattr(getattr(globals()['diffusion_schemes'], diff), diff)\n        except:\n            raise Exception(\"Diffusion scheme \\'\"+diff+\"\\' specified. Valid options for diffusion schemes are:\", diffusion_schemes.__all__)\n\n    if conv is not None:\n        try:\n            self.conv = getattr(getattr(globals()['convection_schemes'], conv), conv)\n        except:\n            raise Exception(\"Convection scheme \\'\"+conv+\"\\' specified. Valid options for convection schemes are:\", convection_schemes.__all__)\n</code></pre>"},{"location":"source_code/#openterrace.openterrace.Simulate.Phase.select_substance","title":"<code>select_substance(substance=None)</code>","text":"<p>Selects one of the predefined substancers.</p> <p>Parameters:</p> Name Type Description Default <code>substance</code> <code>str</code> <p>Substance name</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_substance(self, substance:str=None):\n    \"\"\"Selects one of the predefined substancers.\n\n    Args:\n        substance (str): Substance name\n    \"\"\"\n    if not substance:\n        raise Exception(\"Keyword 'substance' not specified.\")\n    if not substance in self.valid_substances:\n        raise Exception(substance+\" specified as \"+self.type+\" substance. Valid \"+self.type+\" substances are:\", self.valid_substances)\n    self.fcns = getattr(globals()[self.type+'_substances'], substance)\n</code></pre>"},{"location":"source_code/#openterrace.openterrace.Simulate.Phase.select_substance_on_the_fly","title":"<code>select_substance_on_the_fly(cp=None, rho=None, k=None)</code>","text":"<p>Defines and selects a new substance on-the-fly. This is useful for defining a substance for testing purposes with temperature independent properties.</p> <p>Parameters:</p> Name Type Description Default <code>cp</code> <code>float</code> <p>Specific heat capacity in J/(kg K)</p> <code>None</code> <code>rho</code> <code>float</code> <p>Density in kg/m^3</p> <code>None</code> <code>k</code> <code>float</code> <p>Thermal conductivity in W/(m K)</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_substance_on_the_fly(self, cp:float=None, rho:float=None, k:float=None):\n    \"\"\"Defines and selects a new substance on-the-fly. This is useful for defining a substance for testing purposes with temperature independent properties.\n\n    Args:\n        cp (float): Specific heat capacity in J/(kg K)\n        rho (float): Density in kg/m^3\n        k (float): Thermal conductivity in W/(m K)\n    \"\"\"\n    class dummy:\n        pass\n    self.fcns = dummy()\n    self.fcns.h = lambda T: np.ones_like(T)*T*cp\n    self.fcns.T = lambda h: np.ones_like(h)*h/cp\n    self.fcns.cp = lambda h: np.ones_like(h)*cp\n    self.fcns.k = lambda h: np.ones_like(h)*k\n    self.fcns.rho = lambda h: np.ones_like(h)*rho\n</code></pre>"},{"location":"source_code/#openterrace.openterrace.Simulate.__init__","title":"<code>__init__(t_end=None, dt=None, sim_name=None)</code>","text":"<p>Initialise with various control parameters.</p> <p>Parameters:</p> Name Type Description Default <code>t_end</code> <code>float</code> <p>End time in s</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step size in s</p> <code>None</code> <code>sim_name</code> <code>str</code> <p>Simulation name</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def __init__(self, t_end:float=None, dt:float=None, sim_name:str=None):\n    \"\"\"Initialise with various control parameters.\n\n    Args:\n        t_end (float): End time in s\n        dt (float): Time step size in s\n        sim_name (str): Simulation name\n    \"\"\"\n    self.t_start = 0\n    self.t_end = t_end\n    self.dt = dt\n    self.coupling = []\n    self.flag_coupling = False\n    self.sim_name = sim_name\n</code></pre>"},{"location":"source_code/#openterrace.openterrace.Simulate.createPhase","title":"<code>createPhase(n=None, n_other=1, type=None)</code>","text":"<p>Creates a fluid or bed phase.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of discretisations</p> <code>None</code> <code>n_other</code> <code>int</code> <p>Number of discretisations of interacting phase. If you are defining a bed phase within a tank. Then n_other is the number of discretisations of the fluid phase.</p> <code>1</code> <code>type</code> <code>str</code> <p>Simulation name</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def createPhase(self, n:int=None, n_other:int=1, type:str=None):\n    \"\"\"Creates a fluid or bed phase.\n\n    Args:\n        n (int): Number of discretisations\n        n_other (int): Number of discretisations of interacting phase. If you are defining a bed phase within a tank. Then n_other is the number of discretisations of the fluid phase.\n        type (str): Simulation name\n    \"\"\"\n    return self.Phase(self, n, n_other, type)\n</code></pre>"},{"location":"source_code/#openterrace.openterrace.Simulate.run_simulation","title":"<code>run_simulation()</code>","text":"<p>This is the function full of magic.</p> Source code in <code>openterrace/openterrace.py</code> <pre><code>def run_simulation(self):\n    \"\"\"This is the function full of magic.\"\"\"\n    for t in tqdm.tqdm(np.arange(self.t_start, self.t_end+self.dt, self.dt)):\n        for phase_instance in self.Phase.instances:\n            phase_instance._save_data(t)\n            phase_instance._solve_equations(t, self.dt)\n            phase_instance._update_properties()\n        if self.flag_coupling:\n            self._coupling()\n</code></pre>"},{"location":"source_code/#openterrace.openterrace.Simulate.select_coupling","title":"<code>select_coupling(fluid_phase=None, bed_phase=None, h_exp=None, h_value=None)</code>","text":"<p>Selects coupling of a fluid and bed phase</p> <p>Parameters:</p> Name Type Description Default <code>fluid_phase</code> <code>int</code> <p>phase number</p> <code>None</code> <code>bed_phase</code> <code>int</code> <p>phase number</p> <code>None</code> <code>h_exp</code> <code>str</code> <p>Predefined function for convective heat transfer</p> <code>None</code> <code>h_value</code> <code>float</code> <p>Convective heat transfer coefficient in W/(m^2 K)</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_coupling(self, fluid_phase:int=None, bed_phase:int=None, h_exp:str=None, h_value:float=None):\n    \"\"\"Selects coupling of a fluid and bed phase\n\n    Args:\n        fluid_phase (int): phase number\n        bed_phase (int): phase number\n        h_exp (str): Predefined function for convective heat transfer\n        h_value (float): Convective heat transfer coefficient in W/(m^2 K)\n    \"\"\"\n    valid_h_exp = ['constant']\n    if h_exp not in valid_h_exp:\n        raise Exception(\"h_exp \\'\"+h_exp+\"\\' specified. Valid options for h_exp are:\", valid_h_exp)\n\n    self.coupling.append({\"fluid_phase\":fluid_phase, \"bed_phase\":bed_phase, \"h_exp\":h_exp, \"h_value\":h_value})\n    self.flag_coupling = True\n</code></pre>"},{"location":"students/","title":"Student projects","text":"<p>Students are invited to help developing OpenTerrace.</p>"},{"location":"students/#ideas-for-projects","title":"Ideas for projects","text":"<ul> <li>Implement new discretisation schemes and benchmark them</li> <li>Implement new correlations for e.g. convective heat transfer in porous media</li> <li>Benchmark and optimise the code</li> <li>Investigate new types of thermal storage systems by adding different fluids and or materials (also phase change materials)</li> </ul>"},{"location":"theory/","title":"Theory","text":""},{"location":"theory/#schematic-overview","title":"Schematic overview","text":""},{"location":"theory/#governing-equations","title":"Governing equations","text":"<p>OpenTerrace solves partial differential equations for both phases.</p> \\[ \\epsilon_f \\rho_f c_{p,f} \\frac{\\partial T}{\\partial t} = - \\rho_f c_{p,f} u \\frac{\\partial T}{\\partial x} + \\frac{\\partial}{\\partial x}\\left( k_f\\frac{\\partial T}{\\partial x}\\right) + S \\] \\[ \\epsilon_b \\rho_b c_{p,b} \\frac{\\partial T}{\\partial t} = \\frac{\\partial}{\\partial x}\\left( k_b\\frac{\\partial T}{\\partial x}\\right) + S \\] <p>The source term S contains effects such as coupling between the phases or heat loss to surroundings.</p>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#tutorial-1","title":"Tutorial 1","text":"<pre><code>\"\"\" This example shows how to simulate advection of temperature in a cylindrical tank without any bed material. \"\"\"\n\nimport openterrace\n\not = openterrace.Simulate(t_end=600, dt=0.01, sim_name='tutorial1')\n\nfluid = ot.createPhase(n=500, type='fluid')\nfluid.select_substance_on_the_fly(rho=1000, cp=4200, k=0.6)\nfluid.select_domain_shape(domain='cylinder_1d', D=0.3, H=1)\nfluid.select_schemes(diff='central_difference_1d', conv='upwind_1d')\nfluid.select_initial_conditions(T=273.15+100)\nfluid.select_massflow(mdot=0.1)\nfluid.select_bc(bc_type='fixedValue', parameter='T', position=(slice(None, None, None), 0), value=273.15+600)\nfluid.select_bc(bc_type='zeroGradient', parameter='T', position=(slice(None, None, None), -1), value=0)\nfluid.select_output(times=range(0, 15*60+60, 60), parameters=['T'])\n\not.run_simulation()\not.generate_plot(pos_phase=fluid, data_phase=fluid)\not.generate_animation(pos_phase=fluid, data_phase=fluid)\n</code></pre>"},{"location":"tutorials/#tutorial-2","title":"Tutorial 2","text":"<pre><code>\"\"\" This example shows how to simulate advection of temperature in a cylindrical tank without any bed material. \"\"\"\n\nimport openterrace\n\not = openterrace.Simulate(t_end=600, dt=0.01, sim_name='tutorial2')\n\nfluid = ot.createPhase(n=500, type='fluid')\nfluid.select_substance_on_the_fly(rho=1000, cp=4200, k=0.6)\nfluid.select_domain_shape(domain='cylinder_1d', D=0.3, H=1)\nfluid.select_schemes(diff='central_difference_1d', conv='upwind_1d')\nfluid.select_initial_conditions(T=273.15+100)\nfluid.select_massflow(mdot=[\n                            [0, 0.1],\n                            [400, 0.1],\n                            [600, -0.1]\n                            ])\nfluid.select_bc(bc_type='fixedValue', parameter='T', position=(slice(None, None, None), 0), value=273.15+600)\nfluid.select_bc(bc_type='zeroGradient', parameter='T', position=(slice(None, None, None), -1), value=0)\nfluid.select_output(times=range(0, 15*60+60, 60), parameters=['T'])\n\not.run_simulation()\not.generate_plot(pos_phase=fluid, data_phase=fluid)\not.generate_animation(pos_phase=fluid, data_phase=fluid)\n</code></pre>"},{"location":"tutorials/#tutorial-3","title":"Tutorial 3","text":"<pre><code>\"\"\" This example shows how to simulate heat diffusion in a sphere made out of swedish diabase stone. \"\"\"\n\nimport openterrace\n\nR = 0.025\nT_init = 40+273.15\nT_room = 80+273.15\nh = 200\n\not = openterrace.Simulate(t_end=15*60, dt=0.01, sim_name='tutorial3')\n\nbed = ot.createPhase(n=50, type='bed')\nbed.select_substance('swedish_diabase')\nbed.select_domain_shape(domain='sphere_1d', R=R)\nbed.select_schemes(diff='central_difference_1d')\nbed.select_initial_conditions(T=T_init)\nbed.select_bc(bc_type='zeroGradient', parameter='T', position=(slice(None, None, None), 0))\nbed.select_bc(bc_type='zeroGradient', parameter='T', position=(slice(None, None, None), -1))\nbed.select_source_term(source_type='thermal_resistance', R=1/(h*4*3.14159*R**2), T_inf=T_room, position=(slice(None, None, None), -1))\nbed.select_output(times=range(0, 15*60+60, 60), parameters=['T'])\n\not.run_simulation()\not.generate_plot(pos_phase=bed, data_phase=bed)\not.generate_animation(pos_phase=bed, data_phase=bed)\n</code></pre>"},{"location":"tutorials/#tutorial-4","title":"Tutorial 4","text":"<pre><code>\"\"\" This example shows how to simulate heat diffusion in a hollow sphere made out of ATS58 (PCM material). \"\"\"\n\nimport openterrace\n\nRi = 0.005\nRo = 0.025\nT_init = 40+273.15\nT_room = 80+273.15\nh = 50\n\not = openterrace.Simulate(t_end=7200, dt=0.05, sim_name='tutorial4')\n\nbed = ot.createPhase(n=30, type='bed')\nbed.select_substance(substance='ATS58')\nbed.select_domain_shape(domain='hollow_sphere_1d', Rinner=Ri, Router=Ro)\nbed.select_schemes(diff='central_difference_1d')\nbed.select_initial_conditions(T=T_init)\nbed.select_bc(bc_type='zeroGradient', parameter='T', position=(slice(None, None, None), 0))\nbed.select_bc(bc_type='zeroGradient', parameter='T', position=(slice(None, None, None), -1))\nbed.select_source_term(source_type='thermal_resistance', R=1/(h*4*3.14159*Ro**2), T_inf=T_room, position=(slice(None, None, None), -1))\nbed.select_output(times=range(0, 7200, 300), parameters=['T'])\n\not.run_simulation()\not.generate_plot(pos_phase=bed, data_phase=bed)\not.generate_animation(pos_phase=bed, data_phase=bed)\n</code></pre>"},{"location":"tutorials/#tutorial-5","title":"Tutorial 5","text":"<pre><code>\"\"\" \nThis example shows how to simulate a cylindrical thermal storage tank with air and spherical magnetite\nstones as the bed material.\n\"\"\"\n\nimport openterrace\n\nt_end = 3600*20\n\not = openterrace.Simulate(t_end=t_end, dt=0.05, sim_name='tutorial5')\n\nfluid = ot.createPhase(n=50, type='fluid')\nfluid.select_substance(substance='air')\nfluid.select_domain_shape(domain='cylinder_1d', D=0.3, H=1)\nfluid.select_porosity(phi=0.4)\nfluid.select_schemes(diff='central_difference_1d', conv='upwind_1d')\nfluid.select_initial_conditions(T=273.15+25, mdot=0.001)\nfluid.select_bc(bc_type='fixedValue',\n                   parameter='T',\n                   position=(slice(None, None, None), 0),\n                   value=273.15+500\n                   )\nfluid.select_bc(bc_type='zeroGradient',\n                   parameter='T',\n                   position=(slice(None, None, None), -1)\n                   )\nfluid.select_output(times=range(0, t_end+1800, 1800), parameters=['T'])\n\nbed = ot.createPhase(n=20, n_other=50, type='bed')\nbed.select_substance(substance='magnetite')\nbed.select_domain_shape(domain='sphere_1d', R=0.05)\nbed.select_schemes(diff='central_difference_1d')\nbed.select_initial_conditions(T=273.15+25)\nbed.select_output(times=range(0, t_end+1800, 1800), parameters=['T'])\nbed.select_bc(bc_type='zeroGradient',\n                   parameter='T',\n                   position=(slice(None, None, None), 0)\n                   )\nbed.select_bc(bc_type='zeroGradient',\n                   parameter='T',\n                   position=(slice(None, None, None), -1)\n                   )\n\not.select_coupling(fluid_phase=0, bed_phase=1, h_exp='constant', h_value=100)\not.run_simulation()\not.generate_plot(pos_phase=fluid, data_phase=fluid)\not.generate_plot(pos_phase=bed, data_phase=bed)\not.generate_plot(pos_phase=fluid, data_phase=bed)\not.generate_animation(pos_phase=fluid, data_phase=fluid)\n</code></pre>"},{"location":"user-guide/get-started/","title":"Step-by-step guide","text":"<ol> <li>Follow the installation guide to install OpenTerrace.</li> <li>Browse through the tutorials to get an idea of how to set up simulations.</li> <li>Then come back to this section to get more details on the individual steps.</li> </ol>"},{"location":"user-guide/get-started/#import-openterrace-and-define-global-parameters","title":"Import OpenTerrace and define global parameters","text":"<p><pre><code>import openterrace\not = openterrace.Simulate(t_end=3600*6, dt=0.025, n_fluid=50, n_bed=5)\n</code></pre> Line 1: OpenTerrace is imported so we can access its functions</p> <p>Line 2: Create an instance <code>ot</code> and initialise with parameters that control our simulation. They include:</p> <ul> <li> <p><code>t_end</code> (required): End time of the simulation in seconds</p> </li> <li> <p><code>dt</code> (required): Time step size in seconds</p> </li> <li> <p><code>n_fluid</code> (optional): Number of discretisations for the fluid phase (omit if only solving the bed phase)</p> </li> <li> <p><code>n_bed</code> (optional): Number of discretisations for the bed phase (omit if only solving the fluid phase)</p> </li> </ul> <p>Note, either <code>n_fluid</code> or <code>n_bed</code> should be specified. If either is omitted that phase wont be simulated.</p> <p><pre><code>ot.fluid.select_substance(substance='air')\n</code></pre> Line 3: One of the predefined predefined substances is selected as the fluid substance. By using the predefined substances that come with OpenTerrace all properties such as density, viscosity, thermal conductivity will be temperature dependent:</p> <ul> <li><code>substance</code> (required): Name of substance for the phase we are defining</li> </ul> <p>Alternatively, we may define a custom substance on-the-fly with a constant density, specific heat capacity and thermal conductivity by: <pre><code>ot.fluid.select_substance_on_the_fly(rho=1.2, cp=1000, k=0.06)\n</code></pre></p> <ul> <li> <p><code>rho</code> (required): Density in kg/m^3</p> </li> <li> <p><code>cp</code> (required): Specific heat capacity in J/(kg*K)</p> </li> <li> <p><code>k</code> (required): Thermal conductivity in W/(m*K)</p> </li> </ul>"},{"location":"user-guide/get-started/#2-select-a-domain-shape","title":"2. Select a domain shape","text":"<pre><code>ot.fluid.select_domain_shape(domain='cylinder_1d', D=0.5, H=2)\n</code></pre> <ul> <li><code>domain</code> (required): Domain used for the phase</li> </ul> <p>We choose a domain shape using on of the primivite shapes that come built into OpenTerrace. See this list for avialable shapes. Note, each domain will have additional parameters required, e.g. a sphere requires a radius to be defined. You will be prompted to add these if you are missing some.</p>"},{"location":"user-guide/get-started/#3-select-a-porosity-optional","title":"3. Select a porosity (<code>optional</code>)","text":"<pre><code>ot.fluid.select_porosity(phi=0.4)\n</code></pre> <ul> <li><code>phi</code> (required): Porosity m^3/m^3 (e.g. set to 0.4 and the fluid only occupies 40% of the volume)</li> </ul> <p>The domain may be only partially filled with fluid as a bed phase occupies some space. This command may be omitted in which case the fluid occupies the whole domain.</p>"},{"location":"user-guide/get-started/#4-select-discretisation-schemes","title":"4. Select discretisation schemes","text":"<pre><code>ot.fluid.select_schemes(diff='central_difference_1d', conv='upwind_1d')\n</code></pre> <ul> <li> <p><code>diff</code> (required): Discretisation scheme for the diffusion term</p> </li> <li> <p><code>conv</code> (required): Discretisation scheme for the convective term</p> </li> </ul> <p>We choose how to discretise our diffusion and convective terms in our governing equations. A list of avialable schemes is avialable here diffusion schemes and convective schemes.</p>"},{"location":"user-guide/get-started/#5-select-intial-conditions","title":"5. Select intial conditions","text":"<pre><code>ot.fluid.select_initial_conditions(T=273.15+50, mdot=0.1)\n</code></pre> <ul> <li> <p><code>T</code> (required): Temperature in K</p> </li> <li> <p><code>mdot</code> (optional): mass flow rate in kg/s</p> </li> </ul> <p>We choose initial conditions for our simulation in terms of temperature and mass flow rate.</p>"},{"location":"user-guide/get-started/#6-select-boundary-conditions","title":"6. Select boundary conditions","text":"<pre><code>ot.fluid.select_bc(bc_type='dirichlet', parameter='T', position=(slice(None, None, None), 0), value=273.15+600)\not.fluid.select_bc(bc_type='neumann', parameter='T', position=(slice(None, None, None), -1))\n</code></pre> <ul> <li> <p><code>bc_type</code> (required): Name of the boundary condition type</p> </li> <li> <p><code>parameter</code> (required): Parameter for which you are specifying boundary condition</p> </li> <li> <p><code>position</code> (required): Can be either <code>(slice(None, None, None), 0)</code> for lower bc (e.g. 1d cylinder) or centre boundary (e.g. 1d sphere), or <code>(slice(None, None, None), -1)</code> for upper bc (e.g. 1d cylinder) or surface boundary (e.g. 1d sphere).</p> </li> <li> <p><code>value</code> (required): Specifies the value for <code>dirichlet</code> or <code>dirichlet_timevarying</code> type bcs. </p> </li> </ul>"},{"location":"user-guide/get-started/#setup-the-bed-phase","title":"Setup the bed phase","text":"<p>The bed phase is setup in a similar fashion to the fluid phase. An example is given below:</p> <pre><code>ot.bed.select_substance_on_the_fly(rho=5150, cp=1130, k=1.9)\not.bed.select_domain_shape(domain='sphere_1d', R=0.01)\not.bed.select_schemes(diff='central_difference_1d')\not.bed.select_initial_conditions(T=273.15+50)\not.bed.select_bc(bc_type='neumann', parameter='T', position=(slice(None, None, None), 0))\not.bed.select_bc(bc_type='neumann', parameter='T', position=(slice(None, None, None), -1))\n</code></pre> <p>Note we use neumann type bcs for both boundaries. The coupling between the phases is a source term, which will be added using the <code>coupling</code> keyword next.</p>"},{"location":"user-guide/get-started/#define-phase-interactions-and-post-processing","title":"Define phase interactions and post-processing","text":"<pre><code>ot.select_coupling(h_coeff='constant', h_value=20)\n</code></pre> <ul> <li> <p><code>h_coeff</code> (required): Correlation for the heat transfer coefficient (note currently only <code>constant</code> is available)</p> </li> <li> <p><code>h_value</code> (required): Heat transfer coefficient in W/(m^2*K)</p> </li> </ul> <pre><code>ot.output_animation(save_int=6000, file_name='mySimulations')\n</code></pre> <ul> <li> <p><code>save_int</code> (required): Save interval (number of time steps between two successive write outs)</p> </li> <li> <p><code>file_name</code> (optional): Specfies a filename for the animation</p> </li> </ul> <p>Finally, we define how to visualise the results. Here, we save results every 6000 timestep (dt=0.025 s) e.g. every 150 s.</p> <p><pre><code>ot.run_simulation()\n</code></pre> Finally, we execute the simulation and wait for the results to be generated.</p>"},{"location":"user-guide/bed_substances/ATS58/","title":"ATS58","text":"<p>Data for ATS58 phase change material.</p> <p>Reference: https://www.axiotherm.de/en/download/project/productdatasheet/file/19/</p> <p>T_s = 56+273.15 (solidification temperature) T_l = 58+273.15 (liquid temperature) k_s = 1 (solid thermal conductivity) k_l = 0.6 (liquid thermal conductivity) h_f = 240000 (latent heat of fusion) cp = 3000 (specific heat capacity at constant pressure) rho_l = 1280 (liquid density) rho_s = 1280 (solid density) h_s = T_scp (mass specific enthalpy before phase change) h_l = T_scp+h_f (mass specific enthalpy at after phase change)</p>"},{"location":"user-guide/bed_substances/ATS58/#bed_substances.ATS58.T","title":"<code>T(h, p=None)</code>","text":"<p>Temperature as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant cp with phase change).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Temperature in kelvin</p> Source code in <code>openterrace/bed_substances/ATS58.py</code> <pre><code>def T(h:float, p:float=None) -&gt; float:\n    \"\"\"Temperature as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant cp with phase change).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Temperature in kelvin\n    \"\"\"\n    return np.piecewise(h, [h &lt;= _h_s, (h &gt; _h_s) &amp; (h &lt;= _h_l), h &gt; _h_l], [lambda h: 1/_cp*h, lambda h: _T_s + (_T_l-_T_s)*(h-_h_s)/(_h_l-_h_s), lambda h: _T_l + 1/_cp*(h-_h_l)])\n</code></pre>"},{"location":"user-guide/bed_substances/ATS58/#bed_substances.ATS58.cp","title":"<code>cp(h, p=None)</code>","text":"<p>Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant cp with phase change).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Specific heat capacity in J/(kg K)</p> Source code in <code>openterrace/bed_substances/ATS58.py</code> <pre><code>def cp(h:float, p:float=None) -&gt; float:\n    \"\"\"Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant cp with phase change).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Specific heat capacity in J/(kg K)\n    \"\"\"\n    return _cp*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/ATS58/#bed_substances.ATS58.h","title":"<code>h(T)</code>","text":"<p>Mass specific enthalpy as function of temperature at 1 atm (fit assumes piecewice constant cp with phase change).</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>Temperature in K</p> required <p>Returns:</p> Type Description <code>float</code> <p>Specific enthalpy in J/kg</p> Source code in <code>openterrace/bed_substances/ATS58.py</code> <pre><code>def h(T:float) -&gt; float:\n    \"\"\"Mass specific enthalpy as function of temperature at 1 atm (fit assumes piecewice constant cp with phase change).\n\n    Args:\n        T (float): Temperature in K\n\n    Returns:\n        Specific enthalpy in J/kg\n    \"\"\"\n    return np.piecewise(T, [T &lt;= _T_s, (T &gt; _T_s) &amp; (T &lt;= _T_l), T &gt; _T_l], [lambda T: _cp*T, lambda T: _h_s + (T-_T_s)/(_T_l-_T_s)*_h_f, lambda T: _h_l + _cp*(T-_T_l)])\n</code></pre>"},{"location":"user-guide/bed_substances/ATS58/#bed_substances.ATS58.k","title":"<code>k(h, p=None)</code>","text":"<p>Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant k).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Thermal conductivity in W/(m K)</p> Source code in <code>openterrace/bed_substances/ATS58.py</code> <pre><code>def k(h:float, p:float=None) -&gt; float:\n    \"\"\"Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant k).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Thermal conductivity in W/(m K)\n    \"\"\"\n    return np.piecewise(h, [h &lt;= _h_s, (h &gt; _h_s) &amp; (h &lt;= _h_l), h &gt; _h_l], [_k_s, lambda h: _k_s + (_k_l-_k_s)/(_h_l-_h_s)*(h-_h_s), _k_l])\n</code></pre>"},{"location":"user-guide/bed_substances/ATS58/#bed_substances.ATS58.rho","title":"<code>rho(h, p=None)</code>","text":"<p>Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Density in kg/m^3</p> Source code in <code>openterrace/bed_substances/ATS58.py</code> <pre><code>def rho(h:float, p:float=None) -&gt; float:\n    \"\"\"Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Density in kg/m^3\n    \"\"\"\n    return _rho_l*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/magnetite/","title":"Magnetite","text":"<p>Data for Magnetite.</p> <p>cp = 1130 (specific heat capacity at constant pressure) rho = 5150 (density) k = 1.9 (thermal conductivity)</p>"},{"location":"user-guide/bed_substances/magnetite/#bed_substances.magnetite.T","title":"<code>T(h, p=None)</code>","text":"<p>Temperature as function of mass specific enthalpy at 1 atm (fit assumes constant cp).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Temperature in kelvin</p> Source code in <code>openterrace/bed_substances/magnetite.py</code> <pre><code>def T(h:float, p:float=None) -&gt; float:\n    \"\"\"Temperature as function of mass specific enthalpy at 1 atm (fit assumes constant cp).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Temperature in kelvin\n    \"\"\"\n    return 1/1130*h\n</code></pre>"},{"location":"user-guide/bed_substances/magnetite/#bed_substances.magnetite.cp","title":"<code>cp(h, p=None)</code>","text":"<p>Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes constant specific heat capacity).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Specific heat capacity in J/(kg K)</p> Source code in <code>openterrace/bed_substances/magnetite.py</code> <pre><code>def cp(h:float, p:float=None) -&gt; float:\n    \"\"\"Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes constant specific heat capacity).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Specific heat capacity in J/(kg K)\n    \"\"\"\n    return 1130*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/magnetite/#bed_substances.magnetite.h","title":"<code>h(T)</code>","text":"<p>Mass specific enthalpy as function of temperature at 1 atm (fit assumes constant cp).</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>Temperature in K</p> required <p>Returns:</p> Type Description <code>float</code> <p>Specific enthalpy in J/kg</p> Source code in <code>openterrace/bed_substances/magnetite.py</code> <pre><code>def h(T:float) -&gt; float:\n    \"\"\"Mass specific enthalpy as function of temperature at 1 atm (fit assumes constant cp).\n\n    Args:\n        T (float): Temperature in K\n\n    Returns:\n        Specific enthalpy in J/kg\n    \"\"\"\n    return 1130*T\n</code></pre>"},{"location":"user-guide/bed_substances/magnetite/#bed_substances.magnetite.k","title":"<code>k(h, p=None)</code>","text":"<p>Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes constant thermal conductivity).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Thermal conductivity in W/(m K)</p> Source code in <code>openterrace/bed_substances/magnetite.py</code> <pre><code>def k(h:float, p:float=None) -&gt; float:\n    \"\"\"Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes constant thermal conductivity).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Thermal conductivity in W/(m K)\n    \"\"\"\n    return 1.9*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/magnetite/#bed_substances.magnetite.rho","title":"<code>rho(h, p=None)</code>","text":"<p>Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Density in kg/m^3</p> Source code in <code>openterrace/bed_substances/magnetite.py</code> <pre><code>def rho(h:float, p:float=None) -&gt; float:\n    \"\"\"Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Density in kg/m^3\n    \"\"\"\n    return 5150*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/swedish_diabase/","title":"Swedish diabase","text":"<p>Data for Swedish Diabase.</p> <p>cp = 1272 (specific heat capacity at constant pressure) rho = 3007 (density) k = 1.75 (thermal conductivity)</p>"},{"location":"user-guide/bed_substances/swedish_diabase/#bed_substances.swedish_diabase.T","title":"<code>T(h, p=None)</code>","text":"<p>Temperature as function of mass specific enthalpy at 1 atm (fit assumes constant cp).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Temperature in kelvin</p> Source code in <code>openterrace/bed_substances/swedish_diabase.py</code> <pre><code>def T(h:float, p:float=None) -&gt; float:\n    \"\"\"Temperature as function of mass specific enthalpy at 1 atm (fit assumes constant cp).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Temperature in kelvin\n    \"\"\"\n    return 1/1272*h\n</code></pre>"},{"location":"user-guide/bed_substances/swedish_diabase/#bed_substances.swedish_diabase.cp","title":"<code>cp(h, p=None)</code>","text":"<p>Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes constant specific heat capacity).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Specific heat capacity in J/(kg K)</p> Source code in <code>openterrace/bed_substances/swedish_diabase.py</code> <pre><code>def cp(h:float, p:float=None) -&gt; float:\n    \"\"\"Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes constant specific heat capacity).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Specific heat capacity in J/(kg K)\n    \"\"\"\n    return 1272*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/swedish_diabase/#bed_substances.swedish_diabase.h","title":"<code>h(T)</code>","text":"<p>Mass specific enthalpy as function of temperature at 1 atm (fit assumes constant cp).</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>Temperature in K</p> required <p>Returns:</p> Type Description <code>float</code> <p>Specific enthalpy in J/kg</p> Source code in <code>openterrace/bed_substances/swedish_diabase.py</code> <pre><code>def h(T:float) -&gt; float:\n    \"\"\"Mass specific enthalpy as function of temperature at 1 atm (fit assumes constant cp).\n\n    Args:\n        T (float): Temperature in K\n\n    Returns:\n        Specific enthalpy in J/kg\n    \"\"\"\n    return 1272*T\n</code></pre>"},{"location":"user-guide/bed_substances/swedish_diabase/#bed_substances.swedish_diabase.k","title":"<code>k(h, p=None)</code>","text":"<p>Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes constant thermal conductivity).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Thermal conductivity in W/(m K)</p> Source code in <code>openterrace/bed_substances/swedish_diabase.py</code> <pre><code>def k(h:float, p:float=None) -&gt; float:\n    \"\"\"Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes constant thermal conductivity).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Thermal conductivity in W/(m K)\n    \"\"\"\n    return 1.75*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/swedish_diabase/#bed_substances.swedish_diabase.rho","title":"<code>rho(h, p=None)</code>","text":"<p>Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Density in kg/m^3</p> Source code in <code>openterrace/bed_substances/swedish_diabase.py</code> <pre><code>def rho(h:float, p:float=None) -&gt; float:\n    \"\"\"Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Density in kg/m^3\n    \"\"\"\n    return 3007*h**0\n</code></pre>"},{"location":"user-guide/convection_schemes/upwind_1d/","title":"Upwind 1d","text":""},{"location":"user-guide/convection_schemes/upwind_1d/#convection_schemes.upwind_1d.upwind_1d","title":"<code>upwind_1d(x, F)</code>","text":"<p>First-order accurate, unconditionally stable, non-conservative upwind advection scheme.</p> Source code in <code>openterrace/convection_schemes/upwind_1d.py</code> <pre><code>@nb.njit\ndef upwind_1d(x, F):\n    \"\"\"First-order accurate, unconditionally stable, non-conservative upwind advection scheme.\n    \"\"\"\n    _out = np.zeros_like(x)\n    for j in range(0, x.shape[0]):\n        for i in range(1, x.shape[1]-1):\n            _out[j,i] = x[j,i+1]*(-np.minimum(F[0,j,i],0))\\\n                + x[j,i-1]*(np.maximum(F[1,j,i],0))\\\n                + x[j,i]*(np.minimum(F[0,j,i],0)-np.maximum(F[1,j,i],0))\n    return _out\n</code></pre>"},{"location":"user-guide/diffusion_schemes/central_difference_1d/","title":"Central difference 1d","text":""},{"location":"user-guide/diffusion_schemes/central_difference_1d/#diffusion_schemes.central_difference_1d.central_difference_1d","title":"<code>central_difference_1d(x, D)</code>","text":"<p>Second-order accurate central diffence scheme.</p> Source code in <code>openterrace/diffusion_schemes/central_difference_1d.py</code> <pre><code>@nb.njit\ndef central_difference_1d(x, D):\n    \"\"\"Second-order accurate central diffence scheme.\n    \"\"\"\n    _out = np.zeros_like(x)\n    for j in range(0, x.shape[0]):\n        for i in range(1, x.shape[1]-1):\n            _out[j,i] = x[j,i-1]*D[0,j,i] + x[j,i+1]*D[1,j,i]\\\n                - x[j,i]*(D[0,j,i]+D[1,j,i])\n            # _out[j,i] = x[j,i-1]*D[0,j,i] + x[j,i+1]*D[1,j,i]\\\n            #     - x[j,i]*(D[0,j,i]+D[1,j,i])                \n    return _out\n</code></pre>"},{"location":"user-guide/domains/block_1d/","title":"Block 1d","text":""},{"location":"user-guide/domains/block_1d/#domains.block_1d.A","title":"<code>A(vars)</code>","text":"<p>Cross-sectional area for faces of node.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/block_1d.py</code> <pre><code>def A(vars):\n    \"\"\"Cross-sectional area for faces of node.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    A = vars['A']\n    return (np.repeat(A,n), np.repeat(A,n))\n</code></pre>"},{"location":"user-guide/domains/block_1d/#domains.block_1d.V","title":"<code>V(vars)</code>","text":"<p>Volume of node element.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/block_1d.py</code> <pre><code>def V(vars):\n    \"\"\"Volume of node element.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    A = vars['A']\n    L = vars['L']\n    dx = L/(n-1)\n    face_pos_vec = np.concatenate(([0], np.linspace(dx/2,L-dx/2,n-1), [L]))\n    return np.diff(A*face_pos_vec)\n</code></pre>"},{"location":"user-guide/domains/block_1d/#domains.block_1d.dx","title":"<code>dx(vars)</code>","text":"<p>Node spacing function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/block_1d.py</code> <pre><code>def dx(vars):\n    \"\"\"Node spacing function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    L = vars['L']\n    dx = L/(n-1)\n    return np.repeat(dx, n)\n</code></pre>"},{"location":"user-guide/domains/block_1d/#domains.block_1d.node_pos","title":"<code>node_pos(vars)</code>","text":"<p>Node position function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/block_1d.py</code> <pre><code>def node_pos(vars):\n    \"\"\"Node position function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    L = vars['L']\n    return np.array(np.linspace(0,L,n))\n</code></pre>"},{"location":"user-guide/domains/block_1d/#domains.block_1d.shape","title":"<code>shape(vars)</code>","text":"<p>Shape function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/block_1d.py</code> <pre><code>def shape(vars):\n    \"\"\"Shape function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    return np.array([n])\n</code></pre>"},{"location":"user-guide/domains/block_1d/#domains.block_1d.validate_input","title":"<code>validate_input(vars, domain_shape)</code>","text":"<p>Validates input arguments.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required <code>domain_shape</code> <code>str</code> <p>Name of domain type</p> required Source code in <code>openterrace/domains/block_1d.py</code> <pre><code>def validate_input(vars, domain_shape):\n    \"\"\"Validates input arguments.\n\n    Args:\n        vars (list): List of arguments\n        domain_shape (str): Name of domain type\n    \"\"\"\n\n    required = ['n','A','L']\n    for var in required:\n        if not var in vars:\n            raise Exception(\"Keyword \\'\"+var+\"\\' not specified for domain of type \\'\"+domain_shape+\"\\'\")\n</code></pre>"},{"location":"user-guide/domains/cylinder_1d/","title":"Cylinder 1d","text":""},{"location":"user-guide/domains/cylinder_1d/#domains.cylinder_1d.A","title":"<code>A(vars)</code>","text":"<p>Cross-sectional area for faces of node.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/cylinder_1d.py</code> <pre><code>def A(vars):\n    \"\"\"Cross-sectional area for faces of node.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    D = vars['D']\n    H = vars['H']\n    return (np.repeat(np.pi*(D/2)**2, n), np.repeat(np.pi*(D/2)**2, n))\n</code></pre>"},{"location":"user-guide/domains/cylinder_1d/#domains.cylinder_1d.V","title":"<code>V(vars)</code>","text":"<p>Volume of node element.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/cylinder_1d.py</code> <pre><code>def V(vars):\n    \"\"\"Volume of node element.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    D = vars['D']\n    H = vars['H']\n    dx = H/(n-1)\n    face_pos_vec = np.concatenate(([0],np.linspace(dx/2,H-dx/2,n-1),[H]))\n    return np.diff(np.pi*(D/2)**2*face_pos_vec)\n</code></pre>"},{"location":"user-guide/domains/cylinder_1d/#domains.cylinder_1d.dx","title":"<code>dx(vars)</code>","text":"<p>Node spacing function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/cylinder_1d.py</code> <pre><code>def dx(vars):\n    \"\"\"Node spacing function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    H = vars['H']\n    dx = H/(n-1)\n    return np.repeat(dx, n)\n</code></pre>"},{"location":"user-guide/domains/cylinder_1d/#domains.cylinder_1d.node_pos","title":"<code>node_pos(vars)</code>","text":"<p>Node position function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/cylinder_1d.py</code> <pre><code>def node_pos(vars):\n    \"\"\"Node position function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    H = vars['H']\n    return np.array(np.linspace(0,H,n))\n</code></pre>"},{"location":"user-guide/domains/cylinder_1d/#domains.cylinder_1d.shape","title":"<code>shape(vars)</code>","text":"<p>Shape function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/cylinder_1d.py</code> <pre><code>def shape(vars):\n    \"\"\"Shape function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    return np.array([n])\n</code></pre>"},{"location":"user-guide/domains/cylinder_1d/#domains.cylinder_1d.validate_input","title":"<code>validate_input(vars, domain_shape)</code>","text":"<p>Validates input arguments.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required <code>domain_shape</code> <code>str</code> <p>Name of domain type</p> required Source code in <code>openterrace/domains/cylinder_1d.py</code> <pre><code>def validate_input(vars, domain_shape):\n    \"\"\"Validates input arguments.\n\n    Args:\n        vars (list): List of arguments\n        domain_shape (str): Name of domain type\n    \"\"\"\n\n    required = ['n','D','H']\n    for var in required:\n        if not var in vars:\n            raise Exception(\"Keyword \\'\"+var+\"\\' not specified for domain of type \\'\"+domain_shape+\"\\'\")\n</code></pre>"},{"location":"user-guide/domains/hollow_sphere_1d/","title":"Hollow sphere 1d","text":""},{"location":"user-guide/domains/hollow_sphere_1d/#domains.hollow_sphere_1d.A","title":"<code>A(vars)</code>","text":"<p>Cross-sectional area for faces of node.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/hollow_sphere_1d.py</code> <pre><code>def A(vars):\n    \"\"\"Cross-sectional area for faces of node.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    Rinner = vars['Rinner']\n    Router = vars['Router']\n    dx = (Router-Rinner)/(n-1)\n    face_pos_vec = np.concatenate(([Rinner],np.linspace(Rinner+dx/2,Router-dx/2,n-1),[Router]))\n    return np.array([(4*np.pi*face_pos_vec**2)[:-1], (4*np.pi*face_pos_vec**2)[1:]])\n</code></pre>"},{"location":"user-guide/domains/hollow_sphere_1d/#domains.hollow_sphere_1d.V","title":"<code>V(vars)</code>","text":"<p>Volume of node element.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/hollow_sphere_1d.py</code> <pre><code>def V(vars):\n    \"\"\"Volume of node element.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    Rinner = vars['Rinner']\n    Router = vars['Router']\n    dx = (Router-Rinner)/(n-1)\n    face_pos_vec = np.concatenate(([Rinner],np.linspace(Rinner+dx/2,Router-dx/2,n-1),[Router]))\n    return np.diff(4/3*np.pi*face_pos_vec**3)\n</code></pre>"},{"location":"user-guide/domains/hollow_sphere_1d/#domains.hollow_sphere_1d.dx","title":"<code>dx(vars)</code>","text":"<p>Node spacing function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/hollow_sphere_1d.py</code> <pre><code>def dx(vars):\n    \"\"\"Node spacing function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    Rinner = vars['Rinner']\n    Router = vars['Router']\n    dx = (Router-Rinner)/(n-1)\n    return np.repeat(dx, n)\n</code></pre>"},{"location":"user-guide/domains/hollow_sphere_1d/#domains.hollow_sphere_1d.node_pos","title":"<code>node_pos(vars)</code>","text":"<p>Node position function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/hollow_sphere_1d.py</code> <pre><code>def node_pos(vars):\n    \"\"\"Node position function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    Rinner = vars['Rinner']\n    Router = vars['Router']\n    return np.array(np.linspace(Rinner,Router,n))\n</code></pre>"},{"location":"user-guide/domains/hollow_sphere_1d/#domains.hollow_sphere_1d.shape","title":"<code>shape(vars)</code>","text":"<p>Shape function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/hollow_sphere_1d.py</code> <pre><code>def shape(vars):\n    \"\"\"Shape function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    return np.array([n])\n</code></pre>"},{"location":"user-guide/domains/hollow_sphere_1d/#domains.hollow_sphere_1d.validate_input","title":"<code>validate_input(vars, domain_shape)</code>","text":"<p>Validates input arguments.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required <code>domain_shape</code> <code>str</code> <p>Name of domain type</p> required Source code in <code>openterrace/domains/hollow_sphere_1d.py</code> <pre><code>def validate_input(vars, domain_shape):\n    \"\"\"Validates input arguments.\n\n    Args:\n        vars (list): List of arguments\n        domain_shape (str): Name of domain type\n    \"\"\"\n\n    required = ['n','Rinner','Router']\n    for var in required:\n        if not var in vars:\n            raise Exception(\"Keyword \\'\"+var+\"\\' not specified for domain of type \\'\"+domain_shape+\"\\'\")\n</code></pre>"},{"location":"user-guide/domains/sphere_1d/","title":"Sphere 1d","text":""},{"location":"user-guide/domains/sphere_1d/#domains.sphere_1d.A","title":"<code>A(vars)</code>","text":"<p>Cross-sectional area for faces of node.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/sphere_1d.py</code> <pre><code>def A(vars):\n    \"\"\"Cross-sectional area for faces of node.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    R = vars['R']\n    dx = R/(n-1)\n    face_pos_vec = np.concatenate(([0],np.linspace(dx/2,R-dx/2,n-1),[R]))\n    return np.array([(4*np.pi*face_pos_vec**2)[:-1], (4*np.pi*face_pos_vec**2)[1:]])\n</code></pre>"},{"location":"user-guide/domains/sphere_1d/#domains.sphere_1d.V","title":"<code>V(vars)</code>","text":"<p>Volume of node element.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/sphere_1d.py</code> <pre><code>def V(vars):\n    \"\"\"Volume of node element.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    R = vars['R']\n    dx = R/(n-1)\n    face_pos_vec = np.concatenate(([0],np.linspace(dx/2,R-dx/2,n-1),[R]))\n    return np.diff(4/3*np.pi*face_pos_vec**3)\n</code></pre>"},{"location":"user-guide/domains/sphere_1d/#domains.sphere_1d.dx","title":"<code>dx(vars)</code>","text":"<p>Node spacing function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/sphere_1d.py</code> <pre><code>def dx(vars):\n    \"\"\"Node spacing function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    R = vars['R']\n    dx = R/(n-1)\n    return np.repeat(dx, n)\n</code></pre>"},{"location":"user-guide/domains/sphere_1d/#domains.sphere_1d.node_pos","title":"<code>node_pos(vars)</code>","text":"<p>Node position function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/sphere_1d.py</code> <pre><code>def node_pos(vars):\n    \"\"\"Node position function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    R = vars['R']\n    return np.array(np.linspace(0,R,n))\n</code></pre>"},{"location":"user-guide/domains/sphere_1d/#domains.sphere_1d.shape","title":"<code>shape(vars)</code>","text":"<p>Shape function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/sphere_1d.py</code> <pre><code>def shape(vars):\n    \"\"\"Shape function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    return np.array([n])\n</code></pre>"},{"location":"user-guide/domains/sphere_1d/#domains.sphere_1d.validate_input","title":"<code>validate_input(vars, domain_shape)</code>","text":"<p>Validates input arguments.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required <code>domain_shape</code> <code>str</code> <p>Name of domain type</p> required Source code in <code>openterrace/domains/sphere_1d.py</code> <pre><code>def validate_input(vars, domain_shape):\n    \"\"\"Validates input arguments.\n\n    Args:\n        vars (list): List of arguments\n        domain_shape (str): Name of domain type\n    \"\"\"\n\n    required = ['n','R']\n    for var in required:\n        if not var in vars:\n            raise Exception(\"Keyword \\'\"+var+\"\\' not specified for domain of type \\'\"+domain_shape+\"\\'\")\n</code></pre>"},{"location":"user-guide/fluid_substances/air/","title":"Air","text":"<p>Data for atmospheric air.</p> <p>Reference 1: Eric W. Lemmon, Richard T. Jacobsen, Steven G. Penoncello, and Daniel G. Friend. Thermodynamic Properties of Air and Mixtures of Nitrogen, Argon, and Oxygen from 60 to 2000 K at Pressures to 2000 MPa. J. Phys. Chem. Ref. Data, 29(3):331\u2013385, 2000. doi:10.1063/1.1285884. Reference 2: E. W. Lemmon and R. T Jacobsen. Viscosity and Thermal Conductivity Equations for Nitrogen, Oxygen, Argon, and Air. Int. J. Thermophys., 25(1):21\u201369, 2004. doi:10.1023/B:IJOT.0000022327.04529.f3.</p>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.Pr","title":"<code>Pr(h, p=None)</code>","text":"<p>Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Prandtl number</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def Pr(h:float, p:float=None) -&gt; float:\n    \"\"\"Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Prandtl number\n    \"\"\"\n    return 2.71884293e-25*h**4 - 1.12907428e-18*h**3 + 1.70869490e-12*h**2 - 1.05637297e-06*h + 9.25357206e-01\n</code></pre>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.T","title":"<code>T(h, p=None)</code>","text":"<p>Temperature as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Temperature in kelvin</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def T(h:float, p:float=None) -&gt; float:\n    \"\"\"Temperature as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Temperature in kelvin\n    \"\"\"\n    return 9.41315014e-04*h - 9.47094244e+01\n</code></pre>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.cp","title":"<code>cp(h, p=None)</code>","text":"<p>Specific heat capacity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Specific heat capacity in J/(kg K)</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def cp(h:float, p:float=None) -&gt; float:\n    \"\"\"Specific heat capacity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Specific heat capacity in J/(kg K)\n    \"\"\"\n    return -3.31926950e-16*h**3 + 8.48767643e-10*h**2 - 4.95535470e-04*h + 1.08860162e+03\n</code></pre>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.h","title":"<code>h(T)</code>","text":"<p>Mass specific enthalpy as function of temperature at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>Temperature in K</p> required <p>Returns:</p> Type Description <code>float</code> <p>Mass specific enthalpy in J/kg</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def h(T:float) -&gt; float:\n    \"\"\"Mass specific enthalpy as function of temperature at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        T (float): Temperature in K\n\n    Returns:\n        Mass specific enthalpy in J/kg\n    \"\"\"\n    return 1062.3436205*T + 100613.952812\n</code></pre>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.k","title":"<code>k(h, p=None)</code>","text":"<p>Thermal conductivity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Thermal conductivity in W/(m K)</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def k(h:float, p:float=None) -&gt; float:\n    \"\"\"Thermal conductivity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Thermal conductivity in W/(m K)\n    \"\"\"\n    return -1.91985865e-14*h**2 + 8.53813872e-08*h - 6.32545058e-03\n</code></pre>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.mu","title":"<code>mu(h, p=None)</code>","text":"<p>Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Dynamic viscosity in kg/(m s)</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def mu(h:float, p:float=None) -&gt; float:\n    \"\"\"Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Dynamic viscosity in kg/(m s)\n    \"\"\"\n    return -1.49118910e-17*h**2 + 5.64575734e-11*h - 2.65149023e-06\n</code></pre>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.rho","title":"<code>rho(h, p=None)</code>","text":"<p>Density as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Density in kg/m^3</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def rho(h:float, p:float=None) -&gt; float:\n    \"\"\"Density as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Density in kg/m^3\n    \"\"\"\n    return -2.99101902e-18*h**3 + 8.99511511e-12*h**2 - 9.18059393e-06*h + 3.68623992e+00\n</code></pre>"},{"location":"user-guide/fluid_substances/water/","title":"Water","text":"<p>Data for water.</p> <p>Reference 1: W. Wagner and A. Pru\u00df. The IAPWS Formulation 1995 for the Thermodynamic Properties of Ordinary Water Substance for General and Scientific Use. J. Phys. Chem. Ref. Data, 31:387\u2013535, 2002. doi:10.1063/1.1461829. Reference 2: M. L. Huber, R. A. Perkins, D. G. Friend, J. V. Sengers, M. J. Assael, I. N. Metaxa, K. Miyagawa, R. Hellmann, and E. Vogel. New International Formulation for the Thermal Conductivity of H2O. J. Phys. Chem. Ref. Data, 41(3):033102\u20131:23, 2012. doi:10.1063/1.4738955. Reference 3: M. L. Huber, R. A. Perkins, A. Laesecke, D. G. Friend, J. V. Sengers, M. J Assael, I. M. Metaxa, E. Vogel, R. Mare\u0161, and K. Miyagawa. New International Formulation for the Viscosity of H2O. J. Phys. Chem. Ref. Data, 38(2):101\u2013125, 2009. doi:10.1063/1.3088050.</p>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.Pr","title":"<code>Pr(h, p=None)</code>","text":"<p>Prandtl number as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Prandtl number</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def Pr(h:float, p:float=None) -&gt; float:\n    \"\"\"Prandtl number as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Prandtl number\n    \"\"\"\n    return 2.76464299e-10*h**2 - 9.03954950e-05*h + 1.30070174e+01\n</code></pre>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.T","title":"<code>T(h, p=None)</code>","text":"<p>Temperature as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Temperature in kelvin</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def T(h:float, p:float=None) -&gt; float:\n    \"\"\"Temperature as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Temperature in kelvin\n    \"\"\"\n    return 2.38859172e-04*h + 2.73107340e+02\n</code></pre>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.cp","title":"<code>cp(h, p=None)</code>","text":"<p>Specific heat capacity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Specific heat capacity in J/(kg K)</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def cp(h:float, p:float=None) -&gt; float:\n    \"\"\"Specific heat capacity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Specific heat capacity in J/(kg K)\n    \"\"\"\n    return -1.91167239e-15*h**3 + 1.96122501e-09*h**2 - 4.90430569e-04*h**1 + 4.21421348e+03    \n</code></pre>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.h","title":"<code>h(T)</code>","text":"<p>Mass specific enthalpy as function of temperature at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>Temperature in K</p> required <p>Returns:</p> Type Description <code>float</code> <p>Specific enthalpy in J/kg</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def h(T:float) -&gt; float:\n    \"\"\"Mass specific enthalpy as function of temperature at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        T (float): Temperature in K\n\n    Returns:\n        Specific enthalpy in J/kg\n    \"\"\"\n    return 4186.56437769*T - 1143381.31556279\n</code></pre>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.k","title":"<code>k(h, p=None)</code>","text":"<p>Thermal conductivity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Thermal conductivity in W/(m K)</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def k(h:float, p:float=None) -&gt; float:\n    \"\"\"Thermal conductivity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Thermal conductivity in W/(m K)\n    \"\"\"\n    return -5.45934292e-13*h**2 + 5.09161571e-07*h + 5.58152818e-01\n</code></pre>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.mu","title":"<code>mu(h, p=None)</code>","text":"<p>Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Dynamic viscosity in kg/(m*s)</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def mu(h:float, p:float=None) -&gt; float:\n    \"\"\"Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Dynamic viscosity in kg/(m*s)\n    \"\"\"\n    return 1.05996810e-14*h**2 - 7.39076316e-09*h + 1.61251851e-03\n</code></pre>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.rho","title":"<code>rho(h, p=None)</code>","text":"<p>Density as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Density in kg/m^3</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def rho(h:float, p:float=None) -&gt; float:\n    \"\"\"Density as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Density in kg/m^3\n    \"\"\"\n    return -2.01577822e-10*h**2 - 1.84350638e-05*h + 1.00080945e+03\n</code></pre>"},{"location":"user-guide/verification-and-validation/validation/","title":"Validation studies","text":""},{"location":"user-guide/verification-and-validation/verification/","title":"Verification studies","text":""},{"location":"user-guide/verification-and-validation/verification/#pure-diffusion","title":"Pure diffusion","text":""},{"location":"user-guide/verification-and-validation/verification/#pure-advection","title":"Pure advection","text":"<p>To be added...</p>"}]}